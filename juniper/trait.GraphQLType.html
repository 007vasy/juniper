<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `GraphQLType` trait in crate `juniper`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, GraphQLType">

    <title>juniper::GraphQLType - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>juniper</a></p><script>window.sidebarCurrent = {name: 'GraphQLType', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content trait">
<h1 class='fqn'><span class='in-band'>Trait <a href='index.html'>juniper</a>::<wbr><a class='trait' href=''>GraphQLType</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-2006' class='srclink' href='../src/juniper/src/types/base.rs.html#201-266' title='goto source code'>[src]</a></span></h1>
<pre class='rust trait'>pub trait GraphQLType&lt;CtxT&gt;: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a> {
    fn <a href='#tymethod.name' class='fnname'>name</a>() -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;'static <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;;
    fn <a href='#tymethod.meta' class='fnname'>meta</a>(registry: &amp;mut <a class='struct' href='../juniper/struct.Registry.html' title='juniper::Registry'>Registry</a>&lt;CtxT&gt;) -&gt; <a class='enum' href='../juniper/meta/enum.MetaType.html' title='juniper::meta::MetaType'>MetaType</a>;

    fn <a href='#method.resolve_field' class='fnname'>resolve_field</a>(&amp;self, field_name: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, arguments: &amp;<a class='struct' href='../juniper/struct.Arguments.html' title='juniper::Arguments'>Arguments</a>, executor: &amp;mut <a class='struct' href='../juniper/struct.Executor.html' title='juniper::Executor'>Executor</a>&lt;CtxT&gt;) -&gt; <a class='type' href='../juniper/type.ExecutionResult.html' title='juniper::ExecutionResult'>ExecutionResult</a> { ... }
    fn <a href='#method.resolve_into_type' class='fnname'>resolve_into_type</a>(&amp;self, type_name: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, selection_set: <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='enum' href='../juniper/enum.Selection.html' title='juniper::Selection'>Selection</a>&gt;&gt;, executor: &amp;mut <a class='struct' href='../juniper/struct.Executor.html' title='juniper::Executor'>Executor</a>&lt;CtxT&gt;) -&gt; <a class='type' href='../juniper/type.ExecutionResult.html' title='juniper::ExecutionResult'>ExecutionResult</a> { ... }
    fn <a href='#method.concrete_type_name' class='fnname'>concrete_type_name</a>(&amp;self, context: &amp;CtxT) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a> { ... }
    fn <a href='#method.resolve' class='fnname'>resolve</a>(&amp;self, selection_set: <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='enum' href='../juniper/enum.Selection.html' title='juniper::Selection'>Selection</a>&gt;&gt;, executor: &amp;mut <a class='struct' href='../juniper/struct.Executor.html' title='juniper::Executor'>Executor</a>&lt;CtxT&gt;) -&gt; <a class='enum' href='../juniper/enum.Value.html' title='juniper::Value'>Value</a> { ... }
}</pre><div class='docblock'><p>Primary trait used to expose Rust types in a GraphQL schema</p>

<p>All of the convenience macros ultimately expand into an implementation of
this trait for the given type. The macros remove duplicated definitions of
fields and arguments, and add type checks on all resolve functions
automatically. This can all be done manually.</p>

<p><code>GraphQLType</code> provides <em>some</em> convenience methods for you, in the form of
optional trait methods. The <code>name</code> and <code>meta</code> methods are mandatory, but
other than that, it depends on what type you&#39;re exposing:</p>

<ul>
<li>Scalars, enums, lists and non null wrappers only require <code>resolve</code>,</li>
<li>Interfaces and objects require <code>resolve_field</code> <em>or</em> <code>resolve</code> if you want
to implement custom resolution logic (probably not),</li>
<li>Interfaces and unions require <code>resolve_into_type</code> and <code>concrete_type_name</code>.</li>
<li>Input objects do not require anything</li>
</ul>

<h2 id='example' class='section-header'><a href='#example'>Example</a></h2>
<p>Manually deriving an object is straightforward but tedious. This is the
equivalent of the <code>User</code> object as shown in the example in the documentation
root:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>juniper</span>::{<span class='ident'>GraphQLType</span>, <span class='ident'>Registry</span>, <span class='ident'>FieldResult</span>,
              <span class='ident'>Arguments</span>, <span class='ident'>Executor</span>, <span class='ident'>ExecutionResult</span>};
<span class='kw'>use</span> <span class='ident'>juniper</span>::<span class='ident'>meta</span>::<span class='ident'>MetaType</span>;

<span class='kw'>struct</span> <span class='ident'>User</span> { <span class='ident'>id</span>: <span class='ident'>String</span>, <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>friend_ids</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span>  }
<span class='kw'>struct</span> <span class='ident'>Database</span> { <span class='ident'>users</span>: <span class='ident'>HashMap</span><span class='op'>&lt;</span><span class='ident'>String</span>, <span class='ident'>User</span><span class='op'>&gt;</span> }

<span class='kw'>impl</span> <span class='ident'>GraphQLType</span><span class='op'>&lt;</span><span class='ident'>Database</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>User</span> {
    <span class='kw'>fn</span> <span class='ident'>name</span>() <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span><span class='op'>&gt;</span> {
        <span class='prelude-val'>Some</span>(<span class='string'>&quot;User&quot;</span>)
    }

    <span class='kw'>fn</span> <span class='ident'>meta</span>(<span class='ident'>registry</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Registry</span><span class='op'>&lt;</span><span class='ident'>Database</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>MetaType</span> {
        <span class='comment'>// First, we need to define all fields and their types on this type.</span>
        <span class='comment'>//</span>
        <span class='comment'>// If need arguments, want to implement interfaces, or want to add</span>
        <span class='comment'>// documentation strings, we can do it here.</span>
        <span class='ident'>registry</span>.<span class='ident'>build_object_type</span>::<span class='op'>&lt;</span><span class='ident'>User</span><span class='op'>&gt;</span>()(<span class='kw-2'>&amp;</span>[
                <span class='ident'>registry</span>.<span class='ident'>field</span>::<span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>String</span><span class='op'>&gt;</span>(<span class='string'>&quot;id&quot;</span>),
                <span class='ident'>registry</span>.<span class='ident'>field</span>::<span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>String</span><span class='op'>&gt;</span>(<span class='string'>&quot;name&quot;</span>),
                <span class='ident'>registry</span>.<span class='ident'>field</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>User</span><span class='op'>&gt;&gt;</span>(<span class='string'>&quot;friends&quot;</span>),
            ])
            .<span class='ident'>into_meta</span>()
    }

    <span class='kw'>fn</span> <span class='ident'>resolve_field</span>(
        <span class='kw-2'>&amp;</span><span class='self'>self</span>,
        <span class='ident'>field_name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>,
        <span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='ident'>Arguments</span>,
        <span class='ident'>executor</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Executor</span><span class='op'>&lt;</span><span class='ident'>Database</span><span class='op'>&gt;</span>
    )
        <span class='op'>-&gt;</span> <span class='ident'>ExecutionResult</span>
    {
        <span class='comment'>// Next, we need to match the queried field name. All arms of this</span>
        <span class='comment'>// match statement return `ExecutionResult`, which makes it hard to</span>
        <span class='comment'>// statically verify that the type you pass on to `executor.resolve`</span>
        <span class='comment'>// actually matches the one that you defined in `meta()` above.</span>
        <span class='kw'>let</span> <span class='ident'>database</span> <span class='op'>=</span> <span class='ident'>executor</span>.<span class='ident'>context</span>();
        <span class='kw'>match</span> <span class='ident'>field_name</span> {
            <span class='string'>&quot;id&quot;</span> <span class='op'>=&gt;</span> <span class='ident'>executor</span>.<span class='ident'>resolve</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>id</span>),
            <span class='string'>&quot;name&quot;</span> <span class='op'>=&gt;</span> <span class='ident'>executor</span>.<span class='ident'>resolve</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>name</span>),

            <span class='comment'>// You pass a vector of User objects to `executor.resolve`, and it</span>
            <span class='comment'>// will determine which fields of the sub-objects to actually</span>
            <span class='comment'>// resolve based on the query. The executor instance keeps track</span>
            <span class='comment'>// of its current position in the query.</span>
            <span class='string'>&quot;friends&quot;</span> <span class='op'>=&gt;</span> <span class='ident'>executor</span>.<span class='ident'>resolve</span>(
                <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>friend_ids</span>.<span class='ident'>iter</span>()
                    .<span class='ident'>filter_map</span>(<span class='op'>|</span><span class='ident'>id</span><span class='op'>|</span> <span class='ident'>database</span>.<span class='ident'>users</span>.<span class='ident'>get</span>(<span class='ident'>id</span>))
                    .<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>()
            ),

            <span class='comment'>// We can only reach this panic in two cases; either a mismatch</span>
            <span class='comment'>// between the defined schema in `meta()` above, or a validation</span>
            <span class='comment'>// in this library failed because of a bug.</span>
            <span class='comment'>//</span>
            <span class='comment'>// In either of those two cases, the only reasonable way out is</span>
            <span class='comment'>// to panic the thread.</span>
            _ <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Field {} not found on type User&quot;</span>, <span class='ident'>field_name</span>),
        }
    }
}</pre>
</div>
            <h2 id='required-methods'>Required Methods</h2>
            <div class='methods'>
        <h3 id='tymethod.name' class='method stab '><code>fn <a href='#tymethod.name' class='fnname'>name</a>() -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;'static <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;</code></h3><div class='docblock'><p>The name of the GraphQL type to expose.</p>

<p>This function will be called multiple times during schema construction.
It must <em>not</em> perform any calculation and <em>always</em> return the same
value.</p>
</div><h3 id='tymethod.meta' class='method stab '><code>fn <a href='#tymethod.meta' class='fnname'>meta</a>(registry: &amp;mut <a class='struct' href='../juniper/struct.Registry.html' title='juniper::Registry'>Registry</a>&lt;CtxT&gt;) -&gt; <a class='enum' href='../juniper/meta/enum.MetaType.html' title='juniper::meta::MetaType'>MetaType</a></code></h3><div class='docblock'><p>The meta type representing this GraphQL type.</p>
</div></div>
            <h2 id='provided-methods'>Provided Methods</h2>
            <div class='methods'>
        <h3 id='method.resolve_field' class='method stab '><code>fn <a href='#method.resolve_field' class='fnname'>resolve_field</a>(&amp;self, field_name: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, arguments: &amp;<a class='struct' href='../juniper/struct.Arguments.html' title='juniper::Arguments'>Arguments</a>, executor: &amp;mut <a class='struct' href='../juniper/struct.Executor.html' title='juniper::Executor'>Executor</a>&lt;CtxT&gt;) -&gt; <a class='type' href='../juniper/type.ExecutionResult.html' title='juniper::ExecutionResult'>ExecutionResult</a></code></h3><div class='docblock'><p>Resolve the value of a single field on this type.</p>

<p>The arguments object contain all specified arguments, with default
values substituted for the ones not provided by the query.</p>

<p>The executor can be used to drive selections into sub-objects.</p>

<p>The default implementation panics through <code>unimplemented!()</code>.</p>
</div><h3 id='method.resolve_into_type' class='method stab '><code>fn <a href='#method.resolve_into_type' class='fnname'>resolve_into_type</a>(&amp;self, type_name: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, selection_set: <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='enum' href='../juniper/enum.Selection.html' title='juniper::Selection'>Selection</a>&gt;&gt;, executor: &amp;mut <a class='struct' href='../juniper/struct.Executor.html' title='juniper::Executor'>Executor</a>&lt;CtxT&gt;) -&gt; <a class='type' href='../juniper/type.ExecutionResult.html' title='juniper::ExecutionResult'>ExecutionResult</a></code></h3><div class='docblock'><p>Resolve this interface or union into a concrete type</p>

<p>Try to resolve the current type into the type name provided. If the
type matches, pass the instance along to <code>executor.resolve</code>.</p>

<p>The default implementation panics through <code>unimplemented()</code>.</p>
</div><h3 id='method.concrete_type_name' class='method stab '><code>fn <a href='#method.concrete_type_name' class='fnname'>concrete_type_name</a>(&amp;self, context: &amp;CtxT) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='docblock'><p>Return the concrete type name for this instance/union.</p>

<p>The default implementation panics through <code>unimplemented()</code>.</p>
</div><h3 id='method.resolve' class='method stab '><code>fn <a href='#method.resolve' class='fnname'>resolve</a>(&amp;self, selection_set: <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='enum' href='../juniper/enum.Selection.html' title='juniper::Selection'>Selection</a>&gt;&gt;, executor: &amp;mut <a class='struct' href='../juniper/struct.Executor.html' title='juniper::Executor'>Executor</a>&lt;CtxT&gt;) -&gt; <a class='enum' href='../juniper/enum.Value.html' title='juniper::Value'>Value</a></code></h3><div class='docblock'><p>Resolve the provided selection set against the current object.</p>

<p>For non-object types, the selection set will be <code>None</code> and the value
of the object should simply be returned.</p>

<p>For objects, all fields in the selection set should be resolved.</p>

<p>The default implementation uses <code>resolve_field</code> to resolve all fields,
including those through fragment expansion, for object types. For
non-object types, this method panics through <code>unimplemented!()</code>.</p>
</div></div>
        <h2 id='implementors'>Implementors</h2>
        <ul class='item-list' id='implementors-list'>
    <li><code>impl&lt;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='struct' href='../juniper/struct.ID.html' title='juniper::ID'>ID</a></code></li>
<li><code>impl&lt;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a></code></li>
<li><code>impl&lt;'a,&nbsp;CtxT&gt; GraphQLType&lt;CtxT&gt; for &amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a></code></li>
<li><code>impl&lt;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></li>
<li><code>impl&lt;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i64.html'>i64</a></code></li>
<li><code>impl&lt;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a></code></li>
<li><code>impl&lt;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a></code></li>
<li><code>impl&lt;T,&nbsp;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='struct' href='https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html' title='alloc::boxed::Box'>Box</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../juniper/trait.GraphQLType.html' title='juniper::GraphQLType'>GraphQLType</a>&lt;CtxT&gt;</span></code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;CtxT&gt; GraphQLType&lt;CtxT&gt; for &amp;'a T <span class='where'>where T: <a class='trait' href='../juniper/trait.GraphQLType.html' title='juniper::GraphQLType'>GraphQLType</a>&lt;CtxT&gt;</span></code></li>
<li><code>impl&lt;T,&nbsp;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../juniper/trait.GraphQLType.html' title='juniper::GraphQLType'>GraphQLType</a>&lt;CtxT&gt;</span></code></li>
<li><code>impl&lt;T,&nbsp;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../juniper/trait.GraphQLType.html' title='juniper::GraphQLType'>GraphQLType</a>&lt;CtxT&gt;</span></code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;'a [</a>T<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a> <span class='where'>where T: <a class='trait' href='../juniper/trait.GraphQLType.html' title='juniper::GraphQLType'>GraphQLType</a>&lt;CtxT&gt;</span></code></li>
<li><code>impl&lt;CtxT,&nbsp;QueryT,&nbsp;MutationT&gt; GraphQLType&lt;CtxT&gt; for <a class='struct' href='../juniper/struct.RootNode.html' title='juniper::RootNode'>RootNode</a>&lt;CtxT,&nbsp;QueryT,&nbsp;MutationT&gt; <span class='where'>where QueryT: <a class='trait' href='../juniper/trait.GraphQLType.html' title='juniper::GraphQLType'>GraphQLType</a>&lt;CtxT&gt;, MutationT: <a class='trait' href='../juniper/trait.GraphQLType.html' title='juniper::GraphQLType'>GraphQLType</a>&lt;CtxT&gt;</span></code></li>
<li><code>impl GraphQLType&lt;SchemaType&gt; for <a class='struct' href='../juniper/meta/struct.Field.html' title='juniper::meta::Field'>Field</a></code></li>
<li><code>impl GraphQLType&lt;SchemaType&gt; for <a class='struct' href='../juniper/meta/struct.Argument.html' title='juniper::meta::Argument'>Argument</a></code></li>
<li><code>impl GraphQLType&lt;SchemaType&gt; for <a class='struct' href='../juniper/meta/struct.EnumValue.html' title='juniper::meta::EnumValue'>EnumValue</a></code></li>
<li><code>impl&lt;CtxT&gt; GraphQLType&lt;CtxT&gt; for <a class='enum' href='../juniper/enum.TypeKind.html' title='juniper::TypeKind'>TypeKind</a></code></li>
</ul><script type="text/javascript" async
                         src="../implementors/juniper/trait.GraphQLType.js">
                 </script></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "juniper";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>